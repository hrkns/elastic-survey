"use strict";

var __db__ = require('__driver/db'),
	__async__ = require('__driver/myasync').async,
	__notifications__ = require("__driver/notifications"),
	__cache__ = require("__driver/cache"),
	__mongodb__ = require("mongodb");

function conversion(amount, type){
	amount = Number(amount);
	switch(type){
		case "seconds": return amount * 1000;
		case "minutes": return amount * 1000 * 60;
		case "hours": 	return amount * 1000 * 60 * 60;
		case "days": 	return amount * 1000 * 60 * 60 * 24;
		case "weeks": 	return amount * 1000 * 60 * 60 * 24 * 7;
	}
}

module.exports = {
	exec : function(parms){
		var idSurvey = parms.url_data[0];
		var idSection = parms.url_data[2];
		parms.data.id_survey_applying = __mongodb__.ObjectId(parms.data["id_survey_applying"]);
		var cascade = new __async__([
			function(){
				//encontrar registro en base de datos que indique que el usuario está como visitante en la encuesta
				//es decir, que aun no la ha iniciado
				//y que de las secciones que contenga una corresponda con el id de la seccion de la peticion
				__db__.find({
					collection : "user_doing_survey",
					condition : {
						_id : parms.data.id_survey_applying,
						/*status : "initial",*/
						sections : {
							$elemMatch :{
								_id : __mongodb__.ObjectId(idSection)
							}
						}
					},
					callback : function(error, result){
						if(result.length == 1){
							cascade.next(result[0]);
						}else{
						}
					}
				});
			},
			//compruebo que la peticion de iniciado de seccion sea valida
			function(user_doing_survey){
				var esta = false;
				var i = -1;
				var n = user_doing_survey.sections.length;
				while(!esta && ++i < n)
					esta = user_doing_survey.sections[i]._id == idSection;
				//datos coherentes (faltan mas comprobaciones)
				if(esta){
					//no ha sido iniciada
					if(typeof user_doing_survey.sections[i].started_at == "undefined"){
						cascade.next(user_doing_survey, i);
					}else{
						//ya ha sido iniciada, no tiene xq generarse esta peticion
					}
				}else{
				}
			},
			//actualizar status de cuestionario y de seccion
			function(user_doing_survey, pos_section){
				var inicio = new Date();
				var set = {};
				set["status"] = "doing";
				set["actual_section"] = user_doing_survey.sections[pos_section].pausing == "no"?idSection:null;
				set["sections."+pos_section+".started_at"] = inicio;

				if(typeof user_doing_survey.started_at == "undefined")
					set["started_at"] = inicio;

				__db__.update({
					collection : "user_doing_survey",
					condition : {
						_id : parms.data.id_survey_applying
					},
					set : set,
					callback : function(error, result){
						if(user_doing_survey.sections[pos_section].time_limit.type){
							//entonces activo cuenta regresiva
							//insertando en cache
							__cache__.add({
								category : {
									name : "user_doing_survey"
								},
								data: [
									{
										key : parms.data.id_survey_applying+"_"+pos_section,
										data : {
											started_at : inicio,
											finish_at : new Date(inicio.getTime() + conversion(user_doing_survey.sections[pos_section].time_limit.val, user_doing_survey.sections[pos_section].time_limit.type)),
											id_section : idSection,
											id_survey_applying : parms.data.id_survey_applying,
											pos_section : pos_section
										}
									}
								]
							});
							//y de fondo los cron-tasks estarán monitoreando que la misma se termine
							//¿Y SI LO IMPLEMENTO CON UN SETTIMEOUT O ALGO SIMILAR?
						}
						parms.response.writeHead(200, {"Content-Type": "application/json"});
						parms.response.end(JSON.stringify(result));
					}
				});
			}
		]).start();
	}
}