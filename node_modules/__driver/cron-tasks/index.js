"use strict";

/*
	esta libreria implementada por mi permite la ejecucion de manera repetitiva
	en terminos variables de tiempo
	de tareas automatizadas
	se creo como respuesta a la activacion y desactivacion automatica de los cuestionarios
	que poseen una fecha prevista de inicio y/o de fin
*/

var __db__ = require('__driver/db');
var __cache__ = require("__driver/cache");
var __async__ = require('__driver/myasync').async;
var __survey_activation = require("__driver/post/survey/activation.js");
var __survey_closing = require("__driver/post/survey/closing.js");
var __section_closing = require("__driver/post/section/finish.js");
var __notifications__ = require("__driver/notifications");

/*
	ejecuta el procedimiento que activa encuestas
	estas encuestas son todas aquellas con una fecha de inicio prevista
	menor igual a la fecha actual + un excedente
	que para un futuro sera preciso calcularlo con mas exactitud
*/
function startSurveys(){
	var arr = {};
	var nextComputedTime = 1000;
	//fecha techo
	var roofDate = Date.now() + nextComputedTime/2;
	//obtener encuestas de la cache
	__cache__.get({
		category : {
			name : "survey",
			category : {
				name : "not-started"
			}
		},
		condition : function(item){
			return item.start.getTime() <= roofDate;
		}
	}, arr);
	var ids = Array();
	//almacenar id's de los cuestionarios a activar
	for(var survey in arr){
		ids.push(arr[survey]._id);
	}
	if(ids.length)
		//activar cuestionarios, usando el controlador previsto para tal actividad
		__survey_activation.exec({
			ids : ids
		});
	//eliminar de la cache los cuestionarios previstos para activar
	//la insercion de los mismos en la cache pero bajo la categoria survey_ongoing
	//se realiza en el controlador de activacion (invocado previamente)
	__cache__.del({
		category : {
			name : "survey",
			category : {
				name : "not-started"
			}
		},
		condition : function(item){
			return ids.indexOf(item._id) != -1;
		}
	});

	//invocar nuevamente esta misma funcion en un tiempo previsto
	//esto no es recursivo
	setTimeout(startSurveys, nextComputedTime);
}

/*
	ejecuta el procedimiento que desactiva encuestas
	estas encuestas son todas aquellas con una fecha de fin prevista
	menor igual a la fecha actual + un excedente
	que para un futuro sera preciso calcularlo con mas exactitud
*/
function finishSurveys(){
	var arr = {};
	var nextComputedTime = 1000;
	//fecha techo
	var roofDate = Date.now() + nextComputedTime/2;
	//obtener encuestas de la cache
	__cache__.get({
		category : {
			name : "survey",
			category : {
				name : "ongoing"
			}
		},
		condition : function(item){
			return item.end.getTime() <= roofDate;
		}
	}, arr);
	var ids = Array();
	//almacenar id's de los cuestionarios a desactivar
	for(var survey in arr){
		ids.push(arr[survey]._id);
	}
	if(ids.length)
		//desactivar cuestionarios, usando el controlador previsto para tal actividad
		__survey_closing.exec({
			ids : ids
		});

	//eliminar de la cache los cuestionarios previstos para desactivar
	__cache__.del({
		category : {
			name : "survey",
			category : {
				name : "ongoing"
			}
		},
		condition : function(item){
			return ids.indexOf(item._id) != -1;
		}
	});

	//invocar nuevamente esta misma funcion en un tiempo previsto
	//esto no es recursivo
	setTimeout(finishSurveys, nextComputedTime);
}

function closeSection(){
	var arr = {};
	var nextComputedTime = 1000;
	//fecha techo
	var roofDate = Date.now() + nextComputedTime/2;
	//obtener encuestas de la cache
	__cache__.get({
		category : {
			name : "user_doing_survey",
		},
		condition : function(item){
			return item.finish_at.getTime() <= roofDate;
		}
	}, arr);

	//saving keys
	var keys = Array();

	for(var v in arr)
		keys.push(arr[v].id_survey_applying+"_"+arr[v].pos_section);

	if(keys.length){
		//desactivar cuestionarios, usando el controlador previsto para tal actividad
		__section_closing.exec({
			data_sections : arr
		});

		//eliminar de la cache los cuestionarios previstos para desactivar
		__cache__.del({
			category : {
				name : "user_doing_survey"
			},
			condition : function(item){
				return keys.indexOf(item.id_survey_applying+"_"+item.pos_section) != -1;
			}
		});
	}

	//invocar nuevamente esta misma funcion en un tiempo previsto
	//esto no es recursivo
	setTimeout(closeSection, nextComputedTime);
}

module.exports = {
	start : function(parms){
		startSurveys();
		finishSurveys();
		closeSection();
	}
}