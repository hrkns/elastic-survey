"use strict";

/*
	implementacion cutre de una cache
	si bien no podria decirse que esta muy formalizada, sirve para lo que un inicio queria
	hacer, que es tener acceso datos especificos de los cuestionarios que
	tienen prevista una fecha de inicio automatica, 
	y tambien para los que tienen una fecha de cierre automatica
	para no consultar en cada intervalo de tiempo (ver cron-tasks) a la base de datos
	se almacenan en estructuras de datos (warehouse) los cuestionarios que se van
	insertando y actualizando que cumplan con la condicion de que posean una fecha de inicio programada
	o una fecha de cierre programada

	provee cuatro operaciones:
	insercion (add)
	consulta (get)
	modificacion (get)
	eliminacion (del)
*/

var warehouse = {};

/*
	especificar categoria(s) de los items a cargar
	cada item posee una clave asociada, que depende de quien esta insertando
	//IMPLEMENTAR: en caso de que no provea un key, generarlo automaticamente y retornarlo
*/
function add(parms){
	if(parms.category){
		if(parms.category.category){
			//el anidamiento de categorias se logra creando una cadena 
			//con los nombres de las categorias padre e hija unidas por un underscore
			var tmp = parms.category.name;
			parms.category = parms.category.category;
			parms.category.name = tmp + "_" + parms.category.name;
			return add(parms);
		}else{
			//si la categoria no existe, crearla
			if(typeof warehouse[parms.category.name] == "undefined")
				warehouse[parms.category.name] = {};
			//cargar cada elemento con su respectivo key
			for(var v in parms.data)
				warehouse[parms.category.name][parms.data[v]["key"]] = parms.data[v].data;
			return true;
		}
	}
}

/*
	dado una funcion de condicion o cualquier otro filtro
	cargar en un array los elementos que la cumplan
	por ahora solo implementado para una sola categoria
	no se permiten consultas para multiples categorias, lo cual posiblemente seria util
*/
function get(parms, result){
	if(parms.category){
		if(parms.category.category){
			var tmp = parms.category.name;
			parms.category = parms.category.category;
			parms.category.name = tmp + "_" + parms.category.name;
			get(parms, result);
		}else{
			if(typeof warehouse[parms.category.name] != "undefined"){
				for(var v in warehouse[parms.category.name]){
					if(parms.condition(warehouse[parms.category.name][v])){
						result[v] = warehouse[parms.category.name][v];
					}
				}
			}else{
			}
		}
	}
}

/*
	mmodificar elementos de la cache
*/
function set(parms){
	if(parms.category){
		if(parms.category.category){
			var tmp = parms.category.name;
			parms.category = parms.category.category;
			parms.category.name = tmp + "_" + parms.category.name;
			set(parms);
		}else{
			if(typeof warehouse[parms.category.name] != "undefined"){
				if(parms.key){
					warehouse[parms.category.name][parms.key] = parms.data;
				}
			}else{
			}
		}
	}
}

/*eliminar elementos de la cache*/
function del(parms){
	if(parms.category){
		if(parms.category.category){
			var tmp = parms.category.name;
			parms.category = parms.category.category;
			parms.category.name = tmp + "_" + parms.category.name;
			del(parms);
		}else{
			if(typeof warehouse[parms.category.name] != "undefined"){
				if(parms.condition){
					for(var v in warehouse[parms.category.name]){
						if(parms.condition(warehouse[parms.category.name][v])){
							delete warehouse[parms.category.name][v];
						}
					}
				}else if(parms.key){
					try{
						delete warehouse[parms.category.name][parms.key];
					}catch(e){
					}
				}else if(parms.keys){
					for(var v in parms.keys)
						try{
							delete warehouse[parms.category.name][parms.keys[v]];
						}catch(e){
						}
				}
			}else{
			}
		}
	}
}

module.exports = {
	add : add,
	get: get,
	set : set,
	del : del
}

setInterval(function(){
	//console.log(warehouse);
	//console.log("\n");
}, 1000);