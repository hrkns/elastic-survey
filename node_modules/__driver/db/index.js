"use strict";

/*
	minilibreria implementa por mi para manejo de operaciones de base de datos
*/

var MongoClient = require('mongodb').MongoClient;
var format = require('util').format;
var dropCascade = {
	"survey" :  ["survey_section"],
	"survey_section" : ["survey_section_field"],
}

/*eliminar documentos de una coleccion
que cumplan con un conjunto de condiciones dadas*/
function deleteFunction(parms){
	MongoClient.connect('mongodb://127.0.0.1:27017/survey', function(err, db) {
		var deleted_at = new Date();
		//obtener registros de elementos a eliminar
		var cursor = db.collection(parms.collection).find(parms.condition);
		//y se almacenan en este array
		var forInsert = Array();
		var idsForDeleteInCascade = Array();
		cursor.each(function(err, doc) {
			if(err){
			}else{
				if(doc != null){
					//here
					forInsert.push({
						iditem : doc._id,
						item : doc,
						deleted_at : deleted_at/*,
						deleted_by :  user_id*/
					});
					var tmp = {};
					tmp["id_"+parms.collection] = doc._id;
					//y aqui se almacenan los ids de los documentos a borrar, en formato condicional para la eliminacion
					//de documentos en colecciones "hijas" a la coleccion actual
					idsForDeleteInCascade.push(tmp);
				}
				else{
					function deletedFinal(){
						//eliminar elementos de la coleccion que cumplan con la condicion
						db.collection(parms.collection).deleteMany(
							parms.condition,
							function(err, result){
								//si para la coleccion dada, esta posee colecciones que dependen de ella
								//(como las claves foraneas en una base de datos relacional)
								//entonces eliminar documentos de esas colecciones que cumplan
								//con que posean un atributo id_{nombre_de_coleccion_actual} 
								//es decir, la base de datos dise単ada debe cumplir con este formato
								//importante para automatizar [la emulacion de] los DROP CASCADE
								if(dropCascade[parms.collection]){
									var counterDeleted = 0;
									var limit = dropCascade[parms.collection].length;
									//para cada coleccion linkeada como hija de la coleccion actual
									for(var v in dropCascade[parms.collection])
										//implementar funcion de borrado
										deleteFunction({
											collection : dropCascade[parms.collection][v],
											//con la condicion de que sus id_{nombre de coleccion actual} sean iguales a algunos de los documentos
											//eliminados en la operacion previa
											condition : {
												$or : idsForDeleteInCascade
											},
											callback : function(err, rst){
												counterDeleted++;
												//si ya se han eliminado todos los dependientes
												if(counterDeleted == limit)
													//ejecutar callback
													parms.callback(err, result);
											}
										});
								}else{
									parms.callback(err, result);
								}
							}
						);
					}
					if(forInsert.length > 0){
						//si para una condicion dada, hay uno o mas documentos dentro de la coleccion que la cumplen
						//entonces a la coleccion deleted_{collection_name} se le a単aden registros de los elementos eliminados
						//conteniendo los ultimos valores que contenian sus atributos
						db.collection("deleted_"+parms.collection).insert(forInsert, function(x, y){
							//funcion que elimina documentos de la coleccion
							deletedFinal();
						});
					//en caso contrario no hay nada que eliminar
					}else{
						parms.callback(err, null);
					}
				}
			}
		});
	});
}

module.exports = {
	//insercion de uno o mas documentos en una coleccion
	insert : function(parms){
		MongoClient.connect('mongodb://127.0.0.1:27017/survey', function(err, db) {
			if (err) 
				throw err;
			else{
				//a cada elemento a insertar se le a単ade un campo "created_at" 
				//que contiene la fecha (del servidor) en la que fueron a単adidos
				//con el campo updated_at == null se muestra de una manera directa
				//que nunca ha sido modificado
				var now = new Date();
				if(parms.document.hasOwnProperty("indexOf")){
					for(v in parms.document){
						parms.document[v].created_at = now;
						parms.document[v].updated_at = null;
					}
				}else{
					parms.document.created_at = now;
					parms.document.updated_at = null;
				}
				//insercion usando el driver de mongodb
				db.collection(parms.collection).insert(parms.document, function(err, ok){
					if(err){
						parms.callback(true);
					}else{
						//insertamos registro con info asociado a la creacion del elemento
						var n = ok.ops.length;
						var total = 0;

						for(var i = 0; i < n; i++){
							db.collection("created_"+parms.collection).insert({
								"id_item" : ok.ops[i]._id,
								"created_at" : new Date(),
								"info" : ok.ops[i]/*,
								"created_by" : user_id*/
							}, function(x, y){
								total++;

								if(total == n){
									parms.callback(err, ok.ops.length == 1?ok.ops[0]:ok.ops);
								}
							});
						}

						if(n == 0){
							parms.callback(true);
						}
					}
				});
			}
		});
	},
	//busqueda de elementos que cumplan una condicion dada, dentro de una coleccion
	find : function(parms){
		MongoClient.connect('mongodb://127.0.0.1:27017/survey', function(err, db) {
			var cursor = db.collection(parms.collection).find(parms.condition);
			var collections = Array();
			//prescindimos del iterador por defecto y almacenamos los documentos en un array, para luego pasarlo
			//como segundo parametro en el callback
			cursor.each(function(err, doc) {
				if(doc != null)
					collections.push(doc);
				else{
					parms.callback(err, collections);
				}
			});
		});
	},
	//dada una coleccion, actualizamos documentos pertenecientes a ella que cumplan una condicion dada
	update : function(parms){
		MongoClient.connect('mongodb://127.0.0.1:27017/survey', function(err, db) {
			//establecemos la fecha en la cual estan siendo actualizados
			parms.set.updated_at = new Date();
			var cursor = db.collection(parms.collection).find(parms.condition);
			var forInsert = Array();
			cursor.each(function(err, doc) {
				if(doc != null){
					//vamos creando un array que contiene los elementos a insertar en la tabla "updated_{nombre_de_coleccion_actual}"
					//esta coleccion almacena bajo un formato predefinido (fijese en el JSON de la siguiente linea) el historial de cambios 
					//de los documentos de la coleccion actual, en donde estamos actualizando
					forInsert.push({
						iditem : doc._id,
						item : doc,
						updated_at : parms.set.updated_at/*,
						updated_by : user_id*/
					});
				}else{
					if(forInsert.length)
						//si se han detectado elementos que cumplen con la condicion pasada por parametro
						//entonces actualizamos, no sin antes guardar registros de los valores previos
						//a la modificacion
						db.collection("updated_"+parms.collection).insert(forInsert, function(x, y){
							db.collection(parms.collection).updateMany(
								parms.condition,
								{
									$set : parms.set
								},
								parms.callback
							);
						});
					else
						parms.callback(err, null);
				}
			});
		});
	},
	delete : deleteFunction
}