"use strict";

var __db__ = require('__driver/db'),
	__async__ = require('__driver/myasync').async,
	__notifications__ = require("__driver/notifications"),
	__cache__ = require("__driver/cache");

function decodeUrl(url){
	var arr = url.split("/").slice(1);
	return {
		module:arr[0],
		data:arr.slice(1)
	};
};
function shuffle(array, cant) {
	if(typeof cant == "undefined")
		cant = array.length;
	var currentIndex = array.length, temporaryValue, randomIndex;
	var sub = Array();
	// While there remain elements to shuffle...
	while (0 !== currentIndex && cant--) {
		// Pick a remaining element...
		randomIndex = Math.floor(Math.random() * currentIndex);
		currentIndex -= 1;

		// And swap it with the current element.
		temporaryValue = array[currentIndex];
		array[currentIndex] = array[randomIndex];
		array[randomIndex] = temporaryValue;
		sub.push(array[currentIndex]);
	}
	if(currentIndex == 0)
		return array;
	else
		return sub;
}


module.exports = {
	exec : function(request, response){
		var data = decodeUrl(request.originalUrl);
		var hash = data.data[0];
		var survey;
		var finalData = {};

		var async = new __async__([
			function(){
				//verificar si existe en base de datos un cuestionario con el mismo hash, si no existe redirecciono a raiz
				//en caso de que exista, almaceno los datos del mismo de una vez
				__db__.find({
					collection : "survey",
					condition : {
						hash : hash
					}, callback : function(error, d){
						survey = d;
						if(survey.length == 1){
							survey = survey[0];
							survey["stringify_tags"] = JSON.stringify(survey.tags);
							finalData["survey"] = survey;
							async.next();
						}
						else{
							response.writeHeader(301, {
								Location: "/"
							});
							response.end();
						}
					}
				});
			},
			function(){
				//verifico si en base de datos está almacenado un registro que me indique mi status con respecto a la realizacion del cuestionario actual
				//una mejora seria que mientras tenga la sesion abierta, guardar los datos en la variable de sesion
				//obviamente cuando cierre sesion, todo lo guardado ahi se perdera
				//y seria necesario que cuando inicie sesion, se retomen todos esos valores, o mejor dejarlos en base de datos y que se vuelvan a guardar en variable de sesion ingresando nuevamente el cuestionario
				__db__.find({
					collection : "user_doing_survey",
					condition : {
						idsurvey : survey._id,
						iduser : request.session.iduser
					},
					callback : function(err, entries){
						if(entries.length == 1){
							//si no han habido modificaciones del cuestionario desde la ultima vez que entré al mismo (como encuestado)
							if(	(entries[0].survey_data.updated_at == null && survey.updated_at == null) || 
								(entries[0].survey_data.updated_at != null && new Date(entries[0].survey_data.updated_at) - new Date(survey.updated_at) == 0)){ 
								finalData["user_doing_survey"] = entries[0]
								finalData["sections"] = finalData["user_doing_survey"]["sections"];

								//console.log(finalData);
								response.render("survey_live", finalData);
							}else{
								//analizar que tipos de cambio han habido (analisis bastante tricky, a menos que guarde en base de datos de manera explicita que tipo de cambio realicé y sobre que elemento(s) en especifico lo realicé)
								//sin embargo, recordar que cambios a  mtad de aplicacion de un cuestionario es una situacion excepcional que se cubrira posteriormente en el desarrollo, asi que por los momentos son pocas las situaciones a manejar
								//o mejor dicho, si detecto un cambio, eliminar el registro actual y sustituirlo por uno nuevo, es mas facil (a efectos de desarrollo y fecha limite, final de este mes)
								async.next(true);
							}
						}else{
							async.next();
						}
					}
				});
			},
			function(cond){
				if(cond){
					__db__.delete({
						collection : "user_doing_survey",
						condition : {
							iduser : request.session.iduser,
							idsurvey : survey._id
						}, callback : function(error, resultado){
							async.next();
						}
					});
				}else{
					async.next();
				}
			},
			//caigo aqui si no hay registros en base de datos 
			function(){
				__db__.find({
					collection : "survey_section",
					condition : {
						id_survey : survey._id
					},
					callback : function(err, sections){
						if(survey.subset_sections == "yes"){
							if(!(survey.development != "choosen_by_user" && survey.development_type == "loaded"))
								sections = shuffle(sections, Number(survey.subset_sections_amount));
							else{
								var n = sections.length, rand;
								while(n > Number(survey.subset_sections_amount)){
									rand = Math.floor(Math.random() * n);
									sections = sections.slice(0, rand).concat(sections.slice(rand + 1));
									n--;
								}
							}
						}
						sections = (survey.subset_sections == "yes" || survey.development == "choosen_by_user" || survey.development_type == "loaded")?sections:shuffle(sections);
						async.next(sections);
					}
				});
			},
			function(sections){
				var data_sections = Array();
				for(var k in sections)
					data_sections.push({
						_id : sections[k]._id,
						name : sections[k].name,
						description : sections[k].description,
						pausing : sections[k].pausing,
						time_limit : sections[k].time_limit ? sections[k].time_limit : {}
					});
				__db__.insert({
					collection : "user_doing_survey",
					document : {
						iduser : request.session.iduser,
						idsurvey : survey._id,
						status : "initial",
						sections : data_sections,
						survey_data : {
							updated_at : survey.updated_at
						}
					},
					callback : function(error, result){
						finalData["user_doing_survey"] = result.ops[0];
						finalData["sections"] = sections;

						//console.log(finalData);
						response.render("survey_live", finalData);
					}
				});
			}
		]).start();
	}
}